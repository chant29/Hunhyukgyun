///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : sensor.cpp
/// SOFTWARE COMPONENT NAME           : Sensor
/// GENERATED DATE                    : 2024-11-12 08:42:40
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "sensor/aa/sensor.h"

#include <random>

using namespace sl;

namespace sensor
{
namespace aa
{
 
Sensor::Sensor()
    : m_logger(ara::log::CreateLogger("SENS", "SWC", ara::log::LogLevel::kVerbose))
    , m_workers(1)
    , m_running(false)
{
}
 
Sensor::~Sensor()
{
}
 
bool Sensor::Initialize()
{
    m_logger.LogVerbose() << "Sensor::Initialize";
    
    bool init{true};
    
    m_RawData = std::make_shared<sensor::aa::port::RawData>();
    
    return init;
}
 
void Sensor::Start()
{
    m_logger.LogVerbose() << "Sensor::Start";

    InitializeRight();
    InitializeLeft();
    InitializeLidar();

    m_RawData->Start();
    
    // run software component
    Run();
}
 
void Sensor::Terminate()
{
    m_logger.LogVerbose() << "Sensor::Terminate";

    drv->stop();
    drv->setMotorSpeed(0);
    delete drv;
    drv = nullptr;

    m_running = false;

    m_RawData->Terminate();
}
 
void Sensor::Run()
{
    m_logger.LogVerbose() << "Sensor::Run";
    
    m_running = true;RightImage=getRightImage();
}

// 매 1초마다 REvent로 전송할 데이터를 랜덤 값으로 변경하는 함수. ->  카메라와 라이다 data 받아오는 함수로 변경
void Sensor::TaskGenerateREventValue()
{
    while (m_running)
    {
        // RawDataStructure에 맞춰 샘플 데이터를 생성합니다.
        deepracer::service::rawdata::skeleton::events::REvent::SampleType SensorValue;
        if(!UpdateRightImage()){
            InitializeRight();
        }
        else{
            RightImage=getRightImage();
            SensorValue.RCamera.resize(RightImage.total());
            std::memcpy(SensorValue.RCamera.data(), RightImage.data, RightImage.total() * sizeof(uint8_t));
        }

        if(!UpdateLeftImage){
            InitializeRight();
        }
        else{
            LeftImage=getLeftImage();
            SensorValue.LCamera.resize(LeftImage.total());
            std::memcpy(SensorValue.LCamera.data(), LeftImage.data, LeftImage.total() * sizeof(uint8_t));
        }
        SensorValue.Lidar=UpdateLidar();

        // RawData 서비스의 REvent로 전송할 값을 설정합니다. -> 위 3가지 배열이 담긴 구조체를 RawData로 할당
        m_RawData->WriteDataREvent(SensorValue);

        // 1초 대기 -> control period(rawdata의 cyclic 전송주기와 맞춰 주면 될듯)
        std::this_thread::sleep_for(std::chrono::seconds(3));
    }
}

void Sensor::InitializeRight() {
    // Set resolution for both cameras
    RightCamera.set(cv::CAP_PROP_FRAME_WIDTH, 160);
    RightCamera.set(cv::CAP_PROP_FRAME_HEIGHT, 120);

    // Check if cameras are opened successfully
    if (!RightCamera.isOpened()) {
        m_logger.LogInfo() << "RightCamera Failed"; 
    }
}

void Sensor::InitializeLeft() {
    // Set resolution for both cameras
    LeftCamera.set(cv::CAP_PROP_FRAME_WIDTH, 120);
    LeftCamera.set(cv::CAP_PROP_FRAME_HEIGHT, 160);

    // Check if cameras are opened successfully
    if (!LeftCamera.isOpened()) {
        m_logger.LogInfo() << "LeftCamera Failed"; 
    }
}

bool Sensor::UpdateRightImage() {
    // Set resolution for both cameras
    if (!RightCamera.read(RightImage)) {
        m_logger.LogInfo() << "RightCamera Failed";
        return false;
    }
    return true;
}

bool Sensor::UpdateLeftImage() {
    // Set resolution for both cameras
    if (!leftCamera.read(LeftImage)) {
        m_logger.LogInfo() << "LeftCamera Failed";
        return false;
    }
    return true;
}

cv::Mat Sensor::getRightImage() const {
    cv::Mat rightGray;
    cv::cvtColor(RightImage, rightGray, cv::COLOR_BGR2GRAY);
    cv::imwrite("left_camera_gray.jpg", rightGray);
    return rightGray;
}

cv::Mat Sensor::getLeftImage() const {
    cv::Mat leftGray;
    cv::cvtColor(LeftImage, leftGray, cv::COLOR_BGR2GRAY);
    cv::imwrite("left_camera_gray.jpg", leftGray);
    return leftGray;
}

void Sensor::InitializeLidar(){
    const char * dev = "/dev/ttyUSB0";
    unsigned int baudrate = 115200;
    unsigned int op_result;

    // 드라이버 인스턴스 생성
	drv = *createLidarDriver();
    if (!drv) {
        m_logger.LogInfo() << "Lidar Instance Failed";
    }
    // 장치 연결(/dev/ttyUSB0, 115200)
    channel = *createSerialPortChannel(dev, baudrate);
    auto res = (drv)->connect(channel);
    if(!SL_IS_OK(res)){
        m_logger.LogInfo() << "Lidar Failed";
    }
    drv->setMotorSpeed();
    drv->startScan(0,1);
}

std::vector<float> Sensor::UpdateLidar(){
         // 라이다 데이터 수집
    sl_lidar_response_measurement_node_hq_t nodes[8192];
    size_t count = sizeof(nodes) / sizeof(sl_lidar_response_measurement_node_hq_t);
    std::vector<float> lidarData;

    if (SL_IS_OK(m_lidarDriver->grabScanDataHq(nodes, count))) {
        m_lidarDriver->ascendScanData(nodes, count);
        for (size_t pos = 0; pos < count; ++pos) {
            float angle = (nodes[pos].angle_z_q14 * 90.f) / 16384.f;
            float distance = nodes[pos].dist_mm_q2 / 4.0f;

            lidarData.push_back(angle);
            lidarData.push_back(distance);
        }
    }
    return lidarData;
}

} /// namespace aa
} /// namespace sensor
