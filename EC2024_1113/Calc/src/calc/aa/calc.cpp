///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : calc.cpp
/// SOFTWARE COMPONENT NAME           : Calc
/// GENERATED DATE                    : 2024-11-12 08:42:40
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "calc/aa/calc.h"

#include <tensorflow/c/c_api.h>
//#include <tensorflow/core/framework/tensor.h>
//#include <tensorflow/core/platform/env.h>


namespace calc
{
namespace aa
{
 
Calc::Calc()
    : m_logger(ara::log::CreateLogger("CALC", "SWC", ara::log::LogLevel::kVerbose))
    , m_workers(2)
    , m_running(false)
{
}
 
Calc::~Calc()
{
}
 
bool Calc::Initialize()
{
    m_logger.LogVerbose() << "Calc::Initialize";
    
    bool init{true};
    
    m_ControlData = std::make_shared<calc::aa::port::ControlData>();
    m_RawData = std::make_shared<calc::aa::port::RawData>();
    
    return init;
}
 
void Calc::Start()
{
    m_logger.LogVerbose() << "Calc::Start";
    
    m_ControlData->Start();
    m_RawData->Start();
    
    // run software component
    Run();
}
 
void Calc::Terminate()
{
    m_logger.LogVerbose() << "Calc::Terminate";
    m_running = false;
    m_ControlData->Terminate();
    m_RawData->Terminate();
}
 
void Calc::Run()
{
    m_logger.LogVerbose() << "Calc::Run";
    m_running = true;
    m_workers.Async([this] { TaskReceiveREventCyclic(); });
    m_workers.Async([this] { m_ControlData->SendEventCEventCyclic(); });

    
    m_workers.Wait();
}

// RawData REvent의 Cyclic 수신처리에 대한 수행
void Calc::TaskReceiveREventCyclic()
{
    m_RawData->SetReceiveEventREventHandler([this](const auto& sample)
    {
        OnReceiveREvent(sample);
        
    });
    m_RawData->ReceiveEventREventCyclic();
}

// .pb 모델 파일을 읽어 TensorFlow 그래프로 로드하는 멤버 함수
TF_Graph* Calc::LoadGraph(const char* model_path)
{
    // TensorFlow 그래프 초기화
    TF_Graph* graph = TF_NewGraph();
    TF_Status* status = TF_NewStatus();
    TF_Buffer* buffer = TF_NewBuffer();

    // .pb 파일을 바이너리 모드로 열기
    FILE* file = fopen(model_path, "rb");
    if (file == nullptr) {
        m_logger.LogError() << "Error: Could not open model file at path: " << model_path;
        TF_DeleteBuffer(buffer);
        TF_DeleteStatus(status);
        return nullptr;
    }

    // 파일 크기 확인 및 데이터 읽기
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);

    // 모델 데이터 메모리 할당 및 읽기
    char* model_data = new char[file_size];
    fread(model_data, 1, file_size, file);
    fclose(file);

    // 모델 데이터를 TensorFlow Buffer에 설정
    buffer->data = model_data;
    buffer->length = file_size;
    buffer->data_deallocator = [](void* data, size_t) { delete[] static_cast<char*>(data); };

    // 그래프에 모델 정의 추가
    TF_ImportGraphDefOptions* import_opts = TF_NewImportGraphDefOptions();
    TF_GraphImportGraphDef(graph, buffer, import_opts, status);

    // 상태 확인 및 에러 메시지 출력
    if (TF_GetCode(status) != TF_OK) {
        m_logger.LogError() << "Error: Failed to import graph: " << TF_Message(status);
        TF_DeleteImportGraphDefOptions(import_opts);
        TF_DeleteBuffer(buffer);
        TF_DeleteStatus(status);
        return nullptr;
    } else {
        m_logger.LogInfo() << "Model loaded successfully from " << model_path;
    }

    // 메모리 해제
    TF_DeleteImportGraphDefOptions(import_opts);
    TF_DeleteBuffer(buffer);
    TF_DeleteStatus(status);

    return graph;
}



// RawData REvent를 받았을시의 처리 함수 -> 강화학습 파일 거쳐서 결과 값을 로 도출하면 될듯
void Calc::OnReceiveREvent(const deepracer::service::rawdata::proxy::events::REvent::SampleType& sample)
{
    // TensorFlow 초기화
    const char* model_path = "/home/deepracer/EC2024_1113/Calc/src/calc/aa/model.pb";

    TF_Graph* graph = LoadGraph(model_path);
    if (graph == nullptr) {
        m_logger.LogError() << "Failed to load model in OnReceiveREvent.";
        return;
    }

    TF_Status* status = TF_NewStatus();
    TF_SessionOptions* session_options = TF_NewSessionOptions();
    TF_Session* session = TF_NewSession(graph, session_options, status);

    // 모델 파일 로드 (경로를 실제 pb 파일 위치로 바꿔주세요

    if (TF_GetCode(status) != TF_OK) {
        m_logger.LogError() << "Model loading failed: " << TF_Message(status);
        TF_DeleteStatus(status);
        TF_DeleteSessionOptions(session_options);
        TF_DeleteGraph(graph);
        return;
        
    }

    // 주요 플레이스홀더와 출력 연산 설정
    TF_Output camera_input_op = {TF_GraphOperationByName(graph, "main_level/agent/main/online/network_0/STEREO_CAMERAS/STEREO_CAMERAS"), 0};
    TF_Output lidar_input_op = {TF_GraphOperationByName(graph, "main_level/agent/main/online/network_0/SECTOR_LIDAR/SECTOR_LIDAR"), 0};
    TF_Output output_op = {TF_GraphOperationByName(graph, "main_level/agent/main/online/network_1/ppo_head_0/policy_mean/BiasAdd"), 0};

    while (m_running)
    {
        std::vector<uint8_t> stereo_camera_data = m_sensorData.RCamera;
        stereo_camera_data.insert(stereo_camera_data.end(), m_sensorData.LCamera.begin(), m_sensorData.LCamera.end());
        std::vector<float> lidar_data = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8};

        // 텐서 생성
        int64_t camera_dims[] = {1, static_cast<int64_t>(stereo_camera_data.size())};
        TF_Tensor* camera_input_tensor = TF_NewTensor(TF_UINT8, camera_dims, 2, stereo_camera_data.data(), stereo_camera_data.size() * sizeof(uint8_t), [](void* data, size_t, void*) {}, nullptr);

        int64_t lidar_dims[] = {1, static_cast<int64_t>(lidar_data.size())};
        TF_Tensor* lidar_input_tensor = TF_NewTensor(TF_FLOAT, lidar_dims, 2, lidar_data.data(), lidar_data.size() * sizeof(float), [](void* data, size_t, void*) {}, nullptr);

        // 출력 텐서 설정
        TF_Tensor* output_tensors[1] = {nullptr};

        // TensorFlow 세션 실행
        TF_SessionRun(session,
                      nullptr,
                      &camera_input_op, &camera_input_tensor, 1,
                      &lidar_input_op, &lidar_input_tensor, 1,
                      &output_op, output_tensors, 1,
                      nullptr, 0, nullptr, status);

        if (TF_GetCode(status) != TF_OK) {
            m_logger.LogError() << "TensorFlow inference failed: " << TF_Message(status);
        } else {
            // 출력값을 모터 속도 및 조향 값으로 변환
            float* output_data = static_cast<float*>(TF_TensorData(output_tensors[0]));
            deepracer::service::controldata::skeleton::events::CEvent::SampleType CalcValue;
            CalcValue.SpeedServo = output_data[0];   // 추론 결과의 첫 번째 값 (속도)
            CalcValue.SteerServo = output_data[1];   // 추론 결과의 두 번째 값 (조향)

            // CEvent에 값을 기록
            m_ControlData->WriteDataCEvent(CalcValue);
            m_logger.LogInfo() << "Calc::OnReceiveREvent - Speed: " << CalcValue.SpeedServo << ", Steering: " << CalcValue.SteerServo;
        }

        // Tensor 삭제
        TF_DeleteTensor(camera_input_tensor);
        TF_DeleteTensor(lidar_input_tensor);
        TF_DeleteTensor(output_tensors[0]);

        // ControlData의 주기에 맞춰 1초 대기
        std::this_thread::sleep_for(std::chrono::seconds(3));
    }

    // TensorFlow 리소스 해제
    TF_CloseSession(session, status);
    TF_DeleteSession(session, status);
    TF_DeleteGraph(graph);
    TF_DeleteStatus(status);
    TF_DeleteSessionOptions(session_options);
}






} /// namespace aa
} /// namespace calc
